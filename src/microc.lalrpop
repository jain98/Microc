use crate::ast::ast_node::{AstNode, AddOp, MulOp};
use crate::symbol_table::{SymbolTable, NumType};
use crate::symbol_table::decl::{StringDecl, IntDecl, FloatDecl};
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

//////////////////////////
///////// Tokens /////////
//////////////////////////
match {
    // Keywords
    "PROGRAM" => PROGRAM,
    "BEGIN" => BEGIN,
    "END" => END,
    "FUNCTION" => FUNCTION,
    "READ" => READ,
    "WRITE" => WRITE,
    "IF" => IF,
    "ELSE" => ELSE,
    "FI" => FI,
    "FOR" => FOR,
    "ROF" => ROF,
    "RETURN" => RETURN,
    "INT" => INT,
    "VOID" => VOID,
    "STRING" => STRING,
    "FLOAT" => FLOAT,

    // Operators
    ":=",
    "+",
    "-",
    "*",
    "/",
    "=",
    "!=",
    "<",
    ">",
    "(",
    ")",
    ";",
    ",",
    "<=",
    ">=",

    // Identifiers
    r"[a-zA-Z][a-zA-Z0-9]*" => IDENTIFIER,

    // Literals
    r"[0-9]+" => INTLITERAL,
    r"[0-9]+\.[0-9]+|\.[0-9]+" => FLOATLITERAL,
    r#""[^"]*""# => STRINGLITERAL,

    // Discard comments
    r"\s*" => { },
    r"--[^\n\r]*" => { },
}

//////////////////////////
///////// Grammar ////////
//////////////////////////
pub Program: () = {
    PROGRAM IDENTIFIER BEGIN pgm_body end_program,
};

end_program: () = {
    END => {
        SymbolTable::end_curr_scope();
    },
};

empty: () = ();

pgm_body: () = {
    decl func_declarations,
};

decl: () = {
    string_decl decl,
    var_decl decl,
    empty,
};

string_decl: () = {
    STRING <id:IDENTIFIER> ":=" <val:STRINGLITERAL> ";" =>? {
        SymbolTable::add_symbol(StringDecl::new(
            id.to_owned(),
            val.to_owned()
        )).or_else(|decl_err| {
            SymbolTable::set_decl_error(decl_err);
            Err(ParseError::User {
                error: "Encountered declaration error!",
            })
        })
    },
};

var_decl: () = {
    <ty:var_type> <ids:id_list> ";" =>? {
        ids.iter().try_for_each(|&id| {
            match ty {
                NumType::Float => SymbolTable::add_symbol(FloatDecl::new(id.to_owned())),
                NumType::Int => SymbolTable::add_symbol(IntDecl::new(id.to_owned())),
            }.or_else(|decl_err| {
                SymbolTable::set_decl_error(decl_err);
                Err(ParseError::User {
                    error: "Encountered declaration error!",
                })
            })
        })
    },
};

var_type: NumType = {
    FLOAT => NumType::Float,
    INT => NumType::Int,
};

any_type: () = {
    var_type,
    VOID,
};

id_list: Vec<&'input str> = {
    <mut ids: (<IDENTIFIER> ",")*> <id: IDENTIFIER?> => match id {
        Some(id) => {
            ids.push(id);
            ids
        },
        None => ids,
    },
};

param_decl_list: () = {
    param_decl param_decl_tail,
    empty,
};

param_decl: () = {
    <ty:var_type> <id:IDENTIFIER> =>? {
        match ty {
            NumType::Float => SymbolTable::add_symbol(FloatDecl::new(id.to_owned())),
            NumType::Int => SymbolTable::add_symbol(IntDecl::new(id.to_owned())),
        }.or_else(|decl_err| {
            SymbolTable::set_decl_error(decl_err);
            Err(ParseError::User {
                error: "Encountered declaration error!",
            })
        })
    },
};

param_decl_tail: () = {
    "," param_decl param_decl_tail,
    empty,
};

func_declarations: () = {
    func_decl func_declarations,
    empty,
};

func_decl: () = {
    start_func "("param_decl_list")" BEGIN func_body end_func,
};

start_func: () = {
    FUNCTION any_type <id:IDENTIFIER> => {
        SymbolTable::add_scope(id);
    },
};

end_func: () = {
    END => {
        SymbolTable::end_curr_scope();
    },
};

func_body: () = {
    decl stmt_list,
};

stmt_list: () = {
    stmt stmt_list,
    empty,
};

stmt: () = {
    base_stmt,
    if_stmt,
    for_stmt,
};

base_stmt: () = {
    assign_stmt,
    read_stmt,
    write_stmt,
    return_stmt,
};

assign_stmt: () = {
    assign_expr ";",
};

assign_expr: AstNode = {
    <id: IDENTIFIER> ":=" <expr: expr> => {
        let lhs = Box::new(AstNode::Identifier {
            id: id.to_string(),
            sym_type: SymbolTable::symbol_type_for(id).unwrap(),
        });

        let rhs = Box::new(expr);

        let result = AstNode::AssignExpr {
            lhs,
            rhs,
        };
        println!("{:?}", result);
        result
    },
};

read_stmt: AstNode = {
    READ "(" <id_list> ")" ";" => {
        let id_list: Vec<AstNode> = <>
        .iter()
        .map(|id| {
            AstNode::Identifier {
                id: id.to_string(),
                sym_type: SymbolTable::symbol_type_for(id).unwrap(),
            }
        })
        .collect();

        let result = AstNode::ReadExpr(id_list);
        println!("{:?}", result);
        result
    },
};

write_stmt: AstNode = {
    WRITE "(" <id_list> ")" ";" => {
        let id_list: Vec<AstNode> = <>
        .iter()
        .map(|id| {
            AstNode::Identifier {
                id: id.to_string(),
                sym_type: SymbolTable::symbol_type_for(id).unwrap(),
            }
        })
        .collect();

        let result = AstNode::WriteExpr(id_list);
        println!("{:?}", result);
        result
    },
};

return_stmt: () = {
    RETURN expr ";"
};

expr: AstNode = {
    <mut expr_prefix: expr_prefix> <factor: factor> => {
        if let AstNode::AddExpr {
            op: _,
            lhs: _,
            ref mut rhs,
        } = &mut expr_prefix {
            *rhs = Box::new(factor);
            expr_prefix
        } else {
            factor
        }
    },
};

expr_prefix: AstNode = {
    <mut expr_prefix: expr_prefix> <factor: factor> <mut addop: addop> => {
        println!("EXPR_PREFIX: {:?}", expr_prefix);
        println!("FACTOR: {:?}", factor);
        match expr_prefix {
            AstNode::None => {
                if let AstNode::AddExpr {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut addop {
                    *lhs = Box::new(factor);
                }
            },
            _ => {
                if let AstNode::AddExpr {
                    op: _,
                    lhs: _,
                    ref mut rhs,
                } = &mut expr_prefix {
                    *rhs = Box::new(factor);
                }

                if let AstNode::AddExpr {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut addop {
                    *lhs = Box::new(expr_prefix);
                }
            },
        }

        let result = addop;
        println!("RETURNING: {:?}", result);
        result
    },
    empty => AstNode::None,
};

factor: AstNode = {
    <mut factor_prefix: factor_prefix> <postfix_expr: postfix_expr> => {
        if let AstNode::MulExpr {
            op: _,
            lhs: _,
            ref mut rhs,
        } = &mut factor_prefix {
            *rhs = Box::new(postfix_expr);
            factor_prefix
        } else {
            postfix_expr
        }
    },
};

factor_prefix: AstNode = {
    <mut factor_prefix: factor_prefix> <postfix_expr: postfix_expr> <mut mulop: mulop> => {
        match factor_prefix {
            AstNode::None => {
                if let AstNode::MulExpr {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut mulop {
                    *lhs = Box::new(postfix_expr);
                }
            },
            _ => {
                if let AstNode::MulExpr {
                    op: _,
                    lhs: _,
                    ref mut rhs,
                } = &mut factor_prefix {
                    *rhs = Box::new(postfix_expr);
                }

                if let AstNode::MulExpr {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut mulop {
                    *lhs = Box::new(factor_prefix);
                }
            },
        }

        mulop
    },
    empty => AstNode::None,
};

postfix_expr: AstNode = {
    primary,
    call_expr,
};

call_expr: AstNode = {
    IDENTIFIER "(" expr_list ")" => AstNode::IntLiteral(42), // TODO: Fixme!
};

expr_list: () = {
    expr expr_list_tail,
    empty,
};

expr_list_tail: () = {
    "," expr expr_list_tail,
    empty,
};

primary: AstNode = {
    "(" <expr> ")",
    <IDENTIFIER> => {
        // TODO: Handle failure case when symbol does not exist
        let sym_type = SymbolTable::symbol_type_for(<>).unwrap();
        AstNode::Identifier {
            id: <>.to_string(),
            sym_type
        }
    },
    <INTLITERAL> => {
        // TODO: Handle parsing failures
        AstNode::IntLiteral(i32::from_str(<>).unwrap())
    },
    <FLOATLITERAL> => {
        // TODO: Handle parsing failures
        AstNode::FloatLiteral(f64::from_str(<>).unwrap())
    },
};

addop: AstNode = {
    "+" => {
        AstNode::AddExpr {
            op: AddOp::Add,
            lhs: Box::new(AstNode::None),
            rhs: Box::new(AstNode::None),
        }
    },
    "-" => {
       AstNode::AddExpr {
           op: AddOp::Sub,
           lhs: Box::new(AstNode::None),
           rhs: Box::new(AstNode::None),
       }
   },
};

mulop: AstNode = {
    "*" => {
       AstNode::MulExpr {
           op: MulOp::Mul,
           lhs: Box::new(AstNode::None),
           rhs: Box::new(AstNode::None),
       }
   },
    "/" => {
      AstNode::MulExpr {
          op: MulOp::Div,
          lhs: Box::new(AstNode::None),
          rhs: Box::new(AstNode::None),
      }
   },
};

if_stmt: () = {
    start_if "(" cond ")" decl stmt_list else_part end_if_or_else,
};

start_if: () = {
    IF => {
        SymbolTable::add_anonymous_scope();
    },
};

end_if_or_else: () = {
    FI => {
        SymbolTable::end_curr_scope();
    },
};

else_part: () = {
    start_else decl stmt_list,
    empty,
};

start_else: () = {
    ELSE => {
        // End corresponding IF block, which should
        // at this point be the curr scope.
        SymbolTable::end_curr_scope();
        SymbolTable::add_anonymous_scope();
    },
};

cond: () = {
    expr compop expr,
};

compop: () = {
    "<",
    ">",
    "=",
    "!=",
    "<=",
    ">=",
};

init_stmt: () = {
    assign_expr,
    empty,
};

incr_stmt: () = {
    assign_expr,
    empty,
};

for_stmt: () = {
    start_for "(" init_stmt ";" cond ";" incr_stmt ")" decl stmt_list end_for,
};

start_for: () = {
    FOR => {
        SymbolTable::add_anonymous_scope();
    },
};

end_for: () = {
    ROF => {
        SymbolTable::end_curr_scope();
    },
};