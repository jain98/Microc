use crate::ast::ast_node::{AstNode, AddOp, MulOp, Assignment, Condition, Expr, Stmt, Identifier, CmpOp, Item};
use crate::symbol_table::SymbolTable;
use crate::symbol_table::symbol::NumType;
use crate::symbol_table::symbol::{data::{DataSymbol, FunctionDataSymbol, FunctionDataSymbolType}, function::{FunctionSymbol, ReturnType}};
use crate::symbol_table::scope;
use lalrpop_util::ParseError;
use std::str::FromStr;
use std::rc::Rc;

grammar;

//////////////////////////
///////// Tokens /////////
//////////////////////////
match {
    // Keywords
    "PROGRAM" => PROGRAM,
    "BEGIN" => BEGIN,
    "END" => END,
    "FUNCTION" => FUNCTION,
    "READ" => READ,
    "WRITE" => WRITE,
    "IF" => IF,
    "ELSE" => ELSE,
    "FI" => FI,
    "FOR" => FOR,
    "ROF" => ROF,
    "RETURN" => RETURN,
    "INT" => INT,
    "VOID" => VOID,
    "STRING" => STRING,
    "FLOAT" => FLOAT,

    // Operators
    ":=",
    "+",
    "-",
    "*",
    "/",
    "=",
    "!=",
    "<",
    ">",
    "(",
    ")",
    ";",
    ",",
    "<=",
    ">=",

    // Identifiers
    r"[a-zA-Z][a-zA-Z0-9]*" => IDENTIFIER,

    // Literals
    r"[0-9]+" => INTLITERAL,
    r"[0-9]+\.[0-9]+|\.[0-9]+" => FLOATLITERAL,
    r#""[^"]*""# => STRINGLITERAL,

    // Discard comments
    r"\s*" => { },
    r"--[^\n\r]*" => { },
}

//////////////////////////
///////// Grammar ////////
//////////////////////////
pub Program: Vec<AstNode> = {
    PROGRAM IDENTIFIER BEGIN <pgm_body> end_program,
};

end_program: () = {
    END => {
        SymbolTable::end_curr_scope();
    },
};

empty: () = ();

pgm_body: Vec<AstNode> = {
    decl <func_declarations>,
};

decl: () = {
    string_decl decl,
    var_decl decl,
    empty,
};

string_decl: () = {
    STRING <id:IDENTIFIER> ":=" <val:STRINGLITERAL> ";" =>? {
        SymbolTable::add_data_symbol(DataSymbol::String {
            name: id.to_owned(),
            value: val.to_owned()
        }).or_else(|err| {
            SymbolTable::add_symbol_error(err);
            Err(ParseError::User {
                error: "Encountered declaration error!",
            })
        })
    },
};

var_decl: () = {
    <ty:var_type> <ids:id_list> ";" =>? {
        ids.iter().try_for_each(|&id| {
            match ty {
                NumType::Float => SymbolTable::add_data_symbol(DataSymbol::Float { name: id.to_owned()}),
                NumType::Int => SymbolTable::add_data_symbol(DataSymbol::Int { name: id.to_owned()}),
            }.or_else(|err| {
                SymbolTable::add_symbol_error(err);
                Err(ParseError::User {
                    error: "Encountered declaration error!",
                })
            })
        })
    },
};

var_type: NumType = {
    FLOAT => NumType::Float,
    INT => NumType::Int,
};

any_type: ReturnType = {
    <var_type> => match <> {
        NumType::Float => ReturnType::Num(NumType::Float),
        NumType::Int => ReturnType::Num(NumType::Int),
    },
    VOID => ReturnType::Void,
};

id_list: Vec<&'input str> = {
    <mut ids: (<IDENTIFIER> ",")*> <id: IDENTIFIER?> => match id {
        Some(id) => {
            ids.push(id);
            ids
        },
        None => ids,
    },
};

param_decl_list: Vec<NumType> = {
    param_decl param_decl_tail => vec![],
    empty => vec![],
};

param_decl: NumType = {
    <ty:var_type> <id:IDENTIFIER> => {
        match ty {
            NumType::Float => SymbolTable::add_func_data_symbol(id.to_owned(), FunctionDataSymbol::Float{
                symbol_type: FunctionDataSymbolType::Parameter,
                index: scope::get_stack_frame_param_slot_counter(),
            }),
            NumType::Int => SymbolTable::add_func_data_symbol(id.to_owned(), FunctionDataSymbol::Int{
                symbol_type: FunctionDataSymbolType::Local,
                index: scope::get_stack_frame_param_slot_counter(),
            }),
        };
        // .or_else(|err| {
        //     SymbolTable::add_symbol_error(err);
        //     Err(ParseError::User {
        //         error: "Encountered declaration error!",
        //     })
        // });

        ty
    },
};

param_decl_tail: () = {
    "," param_decl param_decl_tail,
    empty,
};

func_local_decl: () = {
    func_local_var_decl func_local_decl,
    empty,
};

func_local_var_decl: () = {
    <ty:var_type> <ids:id_list> ";" =>? {
        ids.iter().try_for_each(|&id| {
            match ty {
                NumType::Float => SymbolTable::add_func_data_symbol(id.to_owned(), FunctionDataSymbol::Float{
                    symbol_type: FunctionDataSymbolType::Local,
                    index: scope::get_stack_frame_local_slot_counter(),
                }),
                NumType::Int => SymbolTable::add_func_data_symbol(id.to_owned(), FunctionDataSymbol::Int{
                    symbol_type: FunctionDataSymbolType::Local,
                    index: scope::get_stack_frame_local_slot_counter(),
                }),
            }.or_else(|err| {
                SymbolTable::add_symbol_error(err);
                Err(ParseError::User {
                    error: "Encountered declaration error!",
                })
            })
        })
    },
};

func_declarations: Vec<AstNode> = {
    <func_decl: func_decl> <mut func_declarations: func_declarations> => {
        func_declarations.push(func_decl);
        func_declarations
    },
    empty => vec![],
};

func_decl: AstNode = {
    <metadata: start_func> "("<params: param_decl_list>")" BEGIN <body: func_body> end_func =>? {
        // Create function symbol
        let func_symbol = FunctionSymbol::new(
            metadata.0,
            metadata.1,
            params,
        );

        // Add function symbol to symbol table
        // SymbolTable::add_function_symbol(func_symbol).or_else(|err| {
        //     SymbolTable::add_symbol_error(err);
        //     Err(ParseError::User {
        //         error: "Encountered declaration error!",
        //     })
        // });
        //
        // // Fetch a Rc pointer to the recently added function symbol from the symbol table
        // let func_symbol = SymbolTable::function_symbol_for_name(&metadata.0).or_else(|err| {
        //     SymbolTable::add_symbol_error(err);
        //     Err(ParseError::User {
        //         error: "Unable to find specified function symbol!",
        //     })
        // }).unwrap();

        // Create the Function node in the AST
        Ok(AstNode::Item(Item::Function {
            symbol: Rc::new(func_symbol), // TODO: temp to fix compilation
            body,
        }))
    },
};

start_func: (String, ReturnType) = {
    FUNCTION <return_type: any_type> <id:IDENTIFIER> => {
        SymbolTable::add_function_scope(id);
        (id.to_owned(), return_type)
    },
};

end_func: () = {
    END => {
        SymbolTable::end_curr_scope();
        scope::reset_stack_frame_local_slot_counter();
        scope::reset_stack_frame_param_slot_counter();
    },
};

func_body: Vec<Stmt> = {
    func_local_decl <stmt_list>,
};

stmt_list: Vec<Stmt> = {
    <stmt: stmt> <mut stmt_list: stmt_list> => {
        stmt_list.push(stmt);
        stmt_list
     },
    empty => vec![],
};

stmt: Stmt = {
    base_stmt,
    if_stmt,
    for_stmt,
};

base_stmt: Stmt = {
    assign_stmt,
    read_stmt,
    write_stmt,
    return_stmt,
};

assign_stmt: Stmt = {
    <assign_expr> ";" => Stmt::Assign(<>),
};

assign_expr: Assignment = {
    <id: IDENTIFIER> ":=" <expr: expr> =>? {
        let symbol = SymbolTable::data_symbol_for_name(id)
            .or_else(|err| {
                SymbolTable::add_symbol_error(err);
                Err(ParseError::User {
                    error: "Encountered declaration error!",
                })
            })?;

        let lhs = Identifier {
            symbol,
        };

        Ok(Assignment {
            lhs,
            rhs: expr,
        })
    },
};

read_stmt: Stmt = {
    READ "(" <id_list> ")" ";" => {
        let id_list: Vec<Identifier> = <>
        .iter()
        .map(|id| {
            // TODO: Handle errors like in assign_expr
            Identifier {
                symbol: SymbolTable::data_symbol_for_name(id).unwrap(),
            }
        })
        .collect();

        Stmt::Read(id_list)
    },
};

write_stmt: Stmt = {
    WRITE "(" <id_list> ")" ";" => {
        let id_list: Vec<Identifier> = <>
        .iter()
        .map(|id| {
        // TODO: Handle errors like in assign_expr
            Identifier {
                symbol: SymbolTable::data_symbol_for_name(id).unwrap(),
            }
        })
        .collect();

        Stmt::Write(id_list)
    },
};

return_stmt: Stmt = {
    RETURN <expr> ";" => todo!(), // TODO: Fixme!
};

expr: Expr = {
    <mut expr_prefix: expr_prefix> <factor: factor> => {
        if let Expr::Add {
            op: _,
            lhs: _,
            ref mut rhs,
        } = &mut expr_prefix {
            *rhs = Box::new(factor);
            expr_prefix
        } else {
            factor
        }
    },
};

expr_prefix: Expr = {
    <mut expr_prefix: expr_prefix> <factor: factor> <mut addop: addop> => {
        match expr_prefix {
            Expr::None => {
                if let Expr::Add {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut addop {
                    *lhs = Box::new(factor);
                }
            },
            _ => {
                if let Expr::Add {
                    op: _,
                    lhs: _,
                    ref mut rhs,
                } = &mut expr_prefix {
                    *rhs = Box::new(factor);
                }

                if let Expr::Add {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut addop {
                    *lhs = Box::new(expr_prefix);
                }
            },
        }

        addop
    },
    empty => Expr::None,
};

factor: Expr = {
    <mut factor_prefix: factor_prefix> <postfix_expr: postfix_expr> => {
        if let Expr::Mul {
            op: _,
            lhs: _,
            ref mut rhs,
        } = &mut factor_prefix {
            *rhs = Box::new(postfix_expr);
            factor_prefix
        } else {
            postfix_expr
        }
    },
};

factor_prefix: Expr = {
    <mut factor_prefix: factor_prefix> <postfix_expr: postfix_expr> <mut mulop: mulop> => {
        match factor_prefix {
            Expr::None => {
                if let Expr::Mul {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut mulop {
                    *lhs = Box::new(postfix_expr);
                }
            },
            _ => {
                if let Expr::Mul {
                    op: _,
                    lhs: _,
                    ref mut rhs,
                } = &mut factor_prefix {
                    *rhs = Box::new(postfix_expr);
                }

                if let Expr::Mul {
                    op: _,
                    ref mut lhs,
                    rhs: _,
                } = &mut mulop {
                    *lhs = Box::new(factor_prefix);
                }
            },
        }

        mulop
    },
    empty => Expr::None,
};

postfix_expr: Expr = {
    primary,
    call_expr,
};

call_expr: Expr = {
    IDENTIFIER "(" expr_list ")" => Expr::IntLiteral(42), // TODO: Fixme!
};

expr_list: () = {
    expr expr_list_tail,
    empty,
};

expr_list_tail: () = {
    "," expr expr_list_tail,
    empty,
};

primary: Expr = {
    "(" <expr> ")",
    <IDENTIFIER> => {
        // TODO: Handle errors like in assign_expr
        Expr::Id(Identifier {
            symbol: SymbolTable::data_symbol_for_name(<>).unwrap(),
        })
    },
    <INTLITERAL> => {
        // TODO: Handle parsing failures
        Expr::IntLiteral(i32::from_str(<>).unwrap())
    },
    <FLOATLITERAL> => {
        // TODO: Handle parsing failures
        Expr::FloatLiteral(f64::from_str(<>).unwrap())
    },
};

addop: Expr = {
    "+" => {
        Expr::Add {
            op: AddOp::Add,
            lhs: Box::new(Expr::None),
            rhs: Box::new(Expr::None),
        }
    },
    "-" => {
       Expr::Add {
           op: AddOp::Sub,
           lhs: Box::new(Expr::None),
           rhs: Box::new(Expr::None),
       }
   },
};

mulop: Expr = {
    "*" => {
       Expr::Mul {
           op: MulOp::Mul,
           lhs: Box::new(Expr::None),
           rhs: Box::new(Expr::None),
       }
   },
    "/" => {
      Expr::Mul {
          op: MulOp::Div,
          lhs: Box::new(Expr::None),
          rhs: Box::new(Expr::None),
      }
   },
};

if_stmt: Stmt = {
    // TODO: What should `decl` return?
    start_if "(" <condition: cond> ")" decl <mut then_block: stmt_list> <mut else_block: else_part> end_if_or_else => {
        // TODO: ADD a comment for why we need to reverse.
        then_block.reverse();
        else_block.reverse();

        Stmt::If {
            condition,
            then_block,
            else_block
        }
    },
};

start_if: () = {
    IF => {
        SymbolTable::add_anonymous_scope();
    },
};

end_if_or_else: () = {
    FI => {
        SymbolTable::end_curr_scope();
    },
};

else_part: Vec<Stmt> = {
    // TODO: What should `decl` return?
    start_else decl <stmt_list: stmt_list> => stmt_list,
    empty => vec![],
};

start_else: () = {
    ELSE => {
        // End corresponding IF block, which should
        // at this point be the curr scope.
        SymbolTable::end_curr_scope();
        SymbolTable::add_anonymous_scope();
    },
};

cond: Condition = {
    <lhs: expr> <cmp_op: compop> <rhs: expr> => Condition {
        cmp_op,
        lhs,
        rhs
    },
};

compop: CmpOp = {
   "<" => CmpOp::Lt,
    ">" => CmpOp::Gt,
    "=" => CmpOp::Eq,
    "!=" => CmpOp::Ne,
    "<=" => CmpOp::Lte,
    ">=" => CmpOp::Gte,
};

init_stmt: Option<Assignment> = {
    <assign_expr> => Some(<>),
    empty => None,
};

incr_stmt: Option<Assignment> = {
    <assign_expr> => Some(<>),
    empty => None,
};

for_stmt: Stmt = {
    // TODO: What should `decl` return?
    start_for "(" <init: init_stmt> ";" <condition: cond> ";" <incr: incr_stmt> ")" decl <mut body: stmt_list> end_for => {
        // TODO: Add a comment for why we need to reverse statements.
        body.reverse();

        Stmt::For {
            init,
            condition,
            incr,
            body,
        }
    }
};

start_for: () = {
    FOR => {
        SymbolTable::add_anonymous_scope();
    },
};

end_for: () = {
    ROF => {
        SymbolTable::end_curr_scope();
    },
};